[{"categories":["本质"],"contents":" 我告诉你，Promise就是有限状态机，这样就容易理解了吧\n一、 有限状态机\n有限个状态\n链式绑定回调函数\n状态转移触发回调函数\n回调函数的绑定和触发也是订阅模式的思想\n","permalink":"https://xiaowoniu22.github.io/posts/post12/","tags":null,"title":"promise就是状态机—挑战一句话解释一个概念"},{"categories":["本质"],"contents":" Hi，原型链就是链表\n一、 节点和连接方式\n原型链上的节点是各种实例对象和原型对象，如： Function.prototype 、 Object.prototype ……\n原型链通过 __proto __ 属性连接各种原型对象\n例如：\narr.__ proto __ = Array.prototype； Array.__ proto __= Object.prototype； Object.__ proto __= null ","permalink":"https://xiaowoniu22.github.io/posts/post11/","tags":null,"title":"原型链就是链表——挑战一句话解释一个概念"},{"categories":null,"contents":" 最近看到一句话，”凡是我不能创造的,我就不能真正理解“，是物理学家费曼的名言，我想，创造的难度还是挺大的，我先来进行一下一句话解释一个概念的挑战\n","permalink":"https://xiaowoniu22.github.io/wunderkammern/wunderkammern2/","tags":null,"title":"新想法"},{"categories":["shader"],"contents":" 有时你会觉得用 GLSL 编程就像是把一搜船放到了瓶子里。它同等地困难、美丽而令人满足。 ——The Book of Shaders\n一、 shader学习资料\nThe Book of Shaders\nThe Study of Shaders with React Three Fiber\n","permalink":"https://xiaowoniu22.github.io/posts/post10/","tags":null,"title":"shader"},{"categories":["线性代数"],"contents":" 引擎推动的不是飞船而是宇宙。飞船压根就没动过。\n一、 模型空间\nModel Matrix将模型空间转换为世界空间\n二、世界空间\nView Matrix将世界空间转换为摄像空间\n三、摄像空间\nProjection Matrix将摄像空间转换为剪裁空间\n四、剪裁空间\n这是一个中心点位于 (0, 0, 0)，角落范围在 (-1, -1, -1) 到 (1, 1, 1) 之间，2 个单位宽的立方体。该剪裁空间被压缩到一个二维空间并栅格化为图像。\n五、GLSL表达\nvoid main() { vUv = uv; u_color = color; vec4 projectedPosition = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0); gl_PointSize = 50.0; gl_Position = projectedPosition; } ","permalink":"https://xiaowoniu22.github.io/posts/post9/","tags":null,"title":"mvp——图形学基础"},{"categories":["线性代数"],"contents":" 有一天我突发奇想，线性代数中的向量是不是就是故事中火柴人一样的存在，线性代数要给我们讲个故事，但是没有人物的故事很难讲下去，于是安排了向量作为故事的主角，故事就徐徐展开了\u0026hellip;\u0026hellip;\n一、 线性变换的本质是空间变换\n线性变换的本质是空间变换，线性代数则是空间变换的代数表达。代数表达是计算的基础。而向量，则只是线性变换的载体。\n二、矩阵与空间变换的关系\n矩阵向量乘法表示线性变换\n矩阵乘法表示线性变换复合\n三、齐次坐标\n齐次坐标真是妙啊。\n空间变换包括平移、缩放和旋转，缩放和旋转都可以用矩阵乘法表示，但是平移是向量加法，为了讲方便计算，将变换统一为矩阵乘法，就引入了齐次坐标。\n平移变换矩阵\n缩放变换矩阵\n绕x轴旋转\n绕y轴旋转\n绕z轴旋转\n三、向量的点积与叉积\n向量的点积的计算结果是个数值，所以点积的结果将多维空间变换为一维。\n向量的叉积表示向量张成空间的面积（或体积），当然要考虑方向（也可以通过行列式计算）。叉积可以在光栅化中计算像素与图元三角形的位置，同号在三角形内，异号在三角形外。\n后边不再纠结线性代数，用到再补充\n","permalink":"https://xiaowoniu22.github.io/posts/post8/","tags":null,"title":"线性代数——图形学基础"},{"categories":null,"contents":" 珍奇屋是15到18世纪间，欧洲收藏家用于陈列自己收藏的稀奇物件和珍贵文物的屋子，是博物馆的前身。\n八、九岁的时候我用鞋盒子给自己做过一个百宝箱，里边存着那个时候自己珍惜的宝贝，有一对喷着金漆的塑料小蟋蟀，站在纸板底座的弹簧叶子上，一碰就摇摇晃晃的动。还有姐姐送的钢笔，方便面里攒的小卡片，漂亮的包装盒\u0026hellip;\u0026hellip;后来因为上学，离家越来越远，二十几年过去，我的百宝箱也没有踪影了。\n如今，在这里造个珍奇屋作为我童年百宝箱的延续吧，记录我的奇怪想法，我的经历，收纳我读过的书，我的奇珍异宝。\n","permalink":"https://xiaowoniu22.github.io/wunderkammern/wunderkammern1/","tags":null,"title":"珍奇屋"},{"categories":["English Learning"],"contents":" 之前很长一段时间，我的英语学习一直停留在没有实质进步但也不愿意放弃的状态。坚持每周做着听力训练，但是数量不足，所以坚持了很长一段时间依然是原本听不懂的现在依然听不懂。最近我决定换个方法试试。\n原版书籍阅读\n1、 找简单易读的英文原版书入门。简单易读，最好有趣味性，能够坚持读下去。我找了《神奇树屋》（Magic Tree House）系列。 2、扩展阅读继续读。读了5本Magic Tree House之后我开始想换个口味，于是开始读同样有趣易读的Roald Dahl的《Matilda》《The Magic Finger》。 3、找自己感兴趣的原版读。读完了以上我看到的这本《One Man\u0026rsquo;s View of hre World》,我本人之一比较喜欢读政经类的书.这本书用词简单，言简意赅，正是我摆脱低龄化英文原著的最好选择。所以很快读完了其中\u0026quot;China-A strong center\u0026quot;,\u0026ldquo;America-Troubled but still on top\u0026rdquo;,\u0026ldquo;Singapore-A nstion at a crossroads\u0026rdquo;，\u0026ldquo;\u0026ldquo;Personal life-Choosing when to go\u0026rdquo;,\u0026ldquo;Conversations with an old friend\u0026quot;五部分。可能基于之前7本原版书的阅读基础，这本书的阅读过程真正让我感受到的原版书的阅读快感，那种之前读中文书才有的停不下来的感觉真是痛快。 4、之前试过但是没读下去的原版书继续拾起来重读。之前读过一本叫《Show Your Work》的书，不厚，不难读，但是在我开始做这一系列原版书阅读训练之前，读的磕磕绊绊，并且没坚持下来。读完上述基本之后我又翻开这本《Show Your Work》，发现读起来流畅了太多，同时我也发现读的过程中我不在关注英语本身，而是关注作者的意图。我这才明白语言只是工具，最重要的是通过语言了解你自己感兴趣的事。之后我打算把这本书的作者的其他几本书看完。 我想我找到了适合自己的英语学习方法，接下来我会按计划大量阅读英语原版书籍，并在输入的基础上制订一个输出计划，后边会继续在此博客中记录和更新。\n以上几本书的阅读完成于2022年上海封控的四月和五月，那是痛苦和煎熬的两个月。如今封控结束，上海基本恢复日常，在此纪念。 ","permalink":"https://xiaowoniu22.github.io/posts/post3/","tags":null,"title":"英语学习——原版书籍阅读"},{"categories":["JS Learning"],"contents":"一、是啥 求值策略（Evaluation strategy）是啥？\n是一种策略 是一种决定什么时候，用什么方式计算函数参数的策略\n是一种分为严格求值和非严格求值的策略 二、为啥 为啥会需要这样一种策略？\n定义一个函数\nfunction sum(x, y) { return x + y; } 调用它\nsum(8, 3); 这时候，问题产生了，编程语言需要在啥时候，用什么方式计算函数参数呢？这就是求值策略存在的意义。 下面用伪代码来解释一下严格求值和非严格求职的执行机制\n//严格求值 function sum(x=8, y=3) { return x + y; } //非严格求值 function sum(x, y) { return (x=8) + (y=3); } 正如所见，严格求值是参数在进入函数之前计算，而非严格求值则是在参数被调用的时候进行计算，不调用，不进行多余计算。\n三、js？ JS中的求值策略是哪一种呢？\n先放结论，JavaScript 语言采用严格求值策略。\n将这一结论作为前提，我们再来解释一下严格求值策略的特性。针对js中的基本数据类型和引用数据类型，从现象倒推，可以总结为传值调用，传引用调用和传共享对象调用。 这里，我借鉴一下Javascript中的求值策略这篇文章中的代码示例\nfunction magic(num, objectA, objectB) { num = num * 6; objectA = {name: \u0026#39;AA\u0026#39;} objectB.name = \u0026#39;BB\u0026#39;; } const num = 1; const objectA = {name: \u0026#39;A\u0026#39;}; const objectB = {name: \u0026#39;B\u0026#39;}; magic(num, objectA, objectB); console.log(num); // 1 console.log(objectA); // {name: \u0026#34;A\u0026#34;} console.log(objectB); // {name: \u0026#34;BB\u0026#34;} console.log(num); // 1 代表传值调用。 参数的num=1，是复制了数字1，所以函数内部的操作不会影响外部的num值。\nconsole.log(objectB);// {name: \u0026ldquo;BB\u0026rdquo;} 则代表传引用调用。 参数中的objectB={name: \u0026lsquo;B\u0026rsquo;}，只是复制objectB的引用，实际还是指向相同的地址，所以函数内部修改objectB的属性，外部的objectB也会受到影响。\nconsole.log(objectA); // {name: \u0026ldquo;A\u0026rdquo;} 代表传共享对象调用。 参数objectA={name: \u0026lsquo;A\u0026rsquo;}，与函数里的操作objectA = {name: \u0026lsquo;AA\u0026rsquo;}，使函数内部和外部是两个独立的object，互不影响，所以函数内部的操作也不会影响外部objectA的值。\n看了好几篇文章，这里是我自己的理解，如有误，请指正。\n延伸 惰性求值\nThunk函数\n参考 Thunk 函数的含义和用法\nJavascript中的求值策略\n求值策略\n","permalink":"https://xiaowoniu22.github.io/posts/post2/","tags":null,"title":"JS中的求值策略"},{"categories":["ARTS"],"contents":"一、Algorithm 365. 水壶问题\n二、Review 3 Examples of When Not to Use JavaScript Arrow Functions\n三个不适用js箭头函数的例子\n1、Object Methods\nObject的方法\n2、Object Prototype\n3、Dynamic Context\n动态语境\n对比什么时候你不能使用箭头函数？\n三、Tip React版本16.4后，使用表格组件，控制台打印Warning信息\n与该问题warning相同React版本更新至16.9.0后，使用表格组件，控制台打印Warning信息\n解决方案 https://www.npmjs.com/package/react-hot-loader#hot-loaderreact-dom\n用@hot-loader/react-dom替代react-dom\n","permalink":"https://xiaowoniu22.github.io/posts/post7/","tags":null,"title":"ARTS打卡计划第四周"},{"categories":["ARTS"],"contents":"一、Algorithm 165. 比较版本号 二、Review 8 Great Websites to Learn New Tech Skills During the Covid-19 Pandemic\n新冠全球爆发，这八个网站助你在家学习新技能\n1. Pluralsight\n这是一个以技术和多媒体为主的在线学习平台，在这里你能找到几乎所有的编程语言或工具的高质量课程。 2. Katacoda 3. Scotch.io\n这是一个前端技术学习网站 4. Udemy.com\n这是一个涵盖了各个学科的综合性学习网站 5. edX\n该网站包含顶尖大学和大公司的计算机科学和编程相关课程 6. Coursera\nCoursera大家都很熟悉，它和edX很像，包含了很多大公司和顶级高校的课程，用户可以在这里获取等级认证证书，当然也可以学习一些个人录制的课程。\n7. Codementor Codementor是一个在线编程指导平台，可提供即时的在线一对一编程辅导。\n8. Bitdegree\n这个网站采用游戏化的模式来使用户得到提升。最初注重科技和软件，现在已经发展到很多其他学科。\n三、Tip 递归引发的血案\n项目中涉及到使用antd树形控件，发现树状渲染引起页面卡顿，百思不得机器，最终发现是因为递归中嵌入了setState\n最终修改为\n页面如丝般顺滑。\n四、Share ","permalink":"https://xiaowoniu22.github.io/posts/post6/","tags":null,"title":"ARTS打卡计划第三周"},{"categories":["React Learning"],"contents":"一、Algorithm 20. 有效的括号 我的思路：\n字符串第一位入栈，之后的每一位依次和前一位匹配，匹配成功，出栈，不成功则入栈。最终，栈为空，则是有效括号，否则无效。\n二、Review 9 Tips for Building Awesome Reusable React Components\n9条编写完美可复用React组件的建议\nUse TypeScript — avoid prop-types\n使用TypeScript做类型检查，避免使用prop-types\nTypeScript and prop-types are currently two of the most popular ways to type-check React code. The former validates types at compile-time, whereas the latter performs at runtime.\nTypeScript and prop-types是目前React中最流行的类型检查方法，前者在编译时检查，而后者则是在运行时检查。 Define Components (Not Just Props \u0026amp; Events)\n定义组件（不只是props 和 Events） Write Your TS in a Way that Enables Auto Documentation\n写TS时要启用文档自动生成功能 Inherit Prop Types for Native-HTML-like Components One Directory For Each Component\n为组件编写目录 Use Aliases Use Enums (Instead of Multiple Booleans) 使用枚举值，而不是过多使用布尔值 Set Defaults Restrict styling with themes\n通过主题限制组件的样式\nTo provide better predictability to your component’s behavior (including its visual appearance) limit the degree of freedom your component consumers have in overriding your component styling properties. 三、Tip 使用gitbook serve 和gitbook build时莫名报错（之前一切正常），如图 解决方法是找到copyPluginAssets.js文件删除或注释第112行\n/.gitbook/versions/版本/lib/output/website/copyPluginAssets.js\n四、Share JS中的求值策略\n","permalink":"https://xiaowoniu22.github.io/posts/post5/","tags":null,"title":"ARTS打卡计划第二周"},{"categories":["React Learning"],"contents":"一、Algorithm 121. 买卖股票的最佳时机\n本人的暴力解法： 最优解法：\n二、Review 4 Best Practices To Write Quality JavaScript Modules\n总结：\n1、Prefer named exports\n使用命名的exports代替default exports；\n2、No work during import\nThe module-level scope shouldn’t do heavy computation like parsing JSON, making HTTP requests, reading local storage, etc.\nmodule作用域中不要进行JSON解析、http请求、读取本地存储等复杂计算\n3、 Favor high cohesion modules\n编写高内聚modules\n4、Avoid long relative paths\n避免使用过长相对路径\n通过webpack或babel-plugin-module-resolver配置根路径的方式处理\n三、Tip 十分想吐槽一下，react-route为什么没有路由嵌套\n四、Share 本周梳理了react中setState的异步机制和批量推迟更新机制\nReact setState合并和批量处理\n","permalink":"https://xiaowoniu22.github.io/posts/post4/","tags":null,"title":"ARTS打卡计划第一周"},{"categories":["React Learning"],"contents":"State的更新什么时候是同步，什么时候是异步\n1、 State的更新什么时候是同步，什么时候是异步。\n正如我们所知，react中使用setState更新state,而state的更新大多数情况下是异步的，但是有些情况却是同步的。 在React中，如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。**\n二、为什么是异步\n如果setState是同步更新state，而state的更新又会触发组件的重新渲染，那么每次setState都会渲染组件，这对性能是很大的消耗。所以react进行了setState的合并和批量延迟更新，正如官网所述：\n三、如何实现setState的合并和批量延迟\n查看react源码发现，代码中有一个变量锁isBatchingUpdates，isBatchingUpdates表示是否进行批量更新，初始化时默认为false，batchedUpdates方法会将isBatchingUpdates设为true\nvar ReactDefaultBatchingStrategy = { isBatchingUpdates: false, batchedUpdates: function(callback, a, b, c, d, e) { var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates; ReactDefaultBatchingStrategy.isBatchingUpdates = true; if (alreadyBatchingUpdates) { return callback(a, b, c, d, e); } else { return transaction.perform(callback, null, a, b, c, d, e); } }, }; module.exports = ReactDefaultBatchingStrategy; 为了合并setState，我们需要一个队列来保存每次setState的数据，然后在一段时间后，清空这个队列并渲染组件，这个队列就是dirtyComponents。当isBatchingUpdates为true时，将会执行 dirtyComponents.push(component); 将组件push到dirtyComponents队列。 调用setState()时，其实已经调用了ReactUpdates.batchedUpdates，此时isBatchingUpdates便是true。\n至此，setState实现了合并和批量处理。\n","permalink":"https://xiaowoniu22.github.io/posts/post1/","tags":null,"title":"React setState合并和批量处理——React"},{"categories":null,"contents":"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labor.\n","permalink":"https://xiaowoniu22.github.io/contact/","tags":null,"title":"Contact Us"},{"categories":null,"contents":"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n","permalink":"https://xiaowoniu22.github.io/author/john-doe/","tags":null,"title":"John Doe"},{"categories":null,"contents":"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n","permalink":"https://xiaowoniu22.github.io/author/mark-dinn/","tags":null,"title":"Mark Dinn"},{"categories":null,"contents":"","permalink":"https://xiaowoniu22.github.io/threejs/","tags":null,"title":"Threejs"}]